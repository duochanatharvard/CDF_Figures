% This function is adopted from Copyright 2010-2011 Timothy E. Holy
% Color outputs from their code are filtered to have only 
function colors = CDF_distinguishable_colors(in_num,bg,func)

    n_colors = in_num * 5;
    
    % Parse the inputs
    if (nargin < 2)
        bg = [1 1 1];  % default white background
    else
        if iscell(bg)
            % User specified a list of colors as a cell aray
            bgc = bg;
            for i = 1:length(bgc)
                bgc{i} = parsecolor(bgc{i});
            end
            bg = cat(1,bgc{:});
        else
            % User specified a numeric array of colors (n-by-3)
            bg = parsecolor(bg);
        end
    end
    
    % Generate a sizable number of RGB triples. This represents our space of
    % possible choices. By starting in RGB space, we ensure that all of the
    % colors can be generated by the monitor.
    n_grid = 30;  % number of grid divisions along each axis in RGB space
    x = linspace(0,1,n_grid);
    [R,G,B] = ndgrid(x,x,x);
    rgb = [R(:) G(:) B(:)];
    if (n_colors > size(rgb,1)/3)
        error('You can''t readily distinguish that many colors');
    end
    
    % Convert to Lab color space, which more closely represents human
    % perception
    if (nargin > 2)
        lab = func(rgb);
        bglab = func(bg);
    else
        C = makecform('srgb2lab');
        lab = applycform(rgb,C);
        bglab = applycform(bg,C);
    end
    
    % If the user specified multiple background colors, compute distances
    % from the candidate colors to the background colors
    mindist2 = inf(size(rgb,1),1);
    for i = 1:size(bglab,1)-1
        dX = bsxfun(@minus,lab,bglab(i,:)); % displacement all colors from bg
        dist2 = sum(dX.^2,2);  % square distance
        mindist2 = min(dist2,mindist2);  % dist2 to closest previously-chosen color
    end
    
    % Iteratively pick the color that maximizes the distance to the nearest
    % already-picked color
    colors = zeros(n_colors,3);
    lastlab = bglab(end,:);   % initialize by making the "previous" color equal to background
    for i = 1:n_colors
        dX = bsxfun(@minus,lab,lastlab); % displacement of last from all colors on list
        dist2 = sum(dX.^2,2);  % square distance
        mindist2 = min(dist2,mindist2);  % dist2 to closest previously-chosen color
        [~,index] = max(mindist2);  % find the entry farthest from all previously-chosen colors
        colors(i,:) = rgb(index,:);  % save for output
        lastlab = lab(index,:);  % prepare for next iteration
    end
    
    % Eliminate colors that are too dark or too bright --------------------
    % In the CDF toolbox, we would always like to throw away dark colors --
    [~,~,Brt] = CDF_generate_HSB(colors);
    colors(Brt < 0.6,:) = [];
    colors = colors(1:in_num,:);
    
end

function c = parsecolor(s)
    if ischar(s)
        c = colorstr2rgb(s);
    elseif isnumeric(s) && size(s,2) == 3
        c = s;
    else
        error('MATLAB:InvalidColorSpec','Color specification cannot be parsed.');
    end
end

function c = colorstr2rgb(c)
    % Convert a color string to an RGB value.
    % This is cribbed from Matlab's whitebg function.
    % Why don't they make this a stand-alone function?
    rgbspec = [1 0 0;0 1 0;0 0 1;1 1 1;0 1 1;1 0 1;1 1 0;0 0 0];
    cspec = 'rgbwcmyk';
    k = find(cspec==c(1));
    if isempty(k)
        error('MATLAB:InvalidColorString','Unknown color string.');
    end
    if k~=3 || length(c)==1,
        c = rgbspec(k,:);
    elseif length(c)>2,
        if strcmpi(c(1:3),'bla')
            c = [0 0 0];
        elseif strcmpi(c(1:3),'blu')
            c = [0 0 1];
        else
            error('MATLAB:UnknownColorString', 'Unknown color string.');
        end
    end
end
